# The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
#
# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
#
# Let us list the factors of the first seven triangle numbers:
#
#  1: 1
#  3: 1,3
#  6: 1,2,3,6
# 10: 1,2,5,10
# 15: 1,3,5,15
# 21: 1,3,7,21
# 28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.
#
# What is the value of the first triangle number to have over five hundred divisors?

import pandas as pd
import numpy as np

def is_prime(n): #boolean function to test if n is prime
  if n == 2 or n == 3: return True
  if n < 2 or n%2 == 0: return False
  if n < 9: return True
  if n%3 == 0: return False
  r = int(n**0.5)
  # since all primes > 3 are of the form 6n Â± 1
  # start with f=5 (which is prime)
  # and test f, f+2 for being prime
  # then loop by 6.
  f = 5
  while f <= r:
    #print('\t',f)
    if n % f == 0: return False
    if n % (f+2) == 0: return False
    f += 6
  return True

# num = 840
# def primefac(n):
#     product = -999
#     factors = np.array([n, 1])
#     oddtest = 3
#     while n > 1:
#         # print(oddtest, n, factors, n % oddtest, "n/odd",n / oddtest)
#         if n % 2 == 0:
#             if n == 2:
#                 return factors
#             n = n / 2
#             n = int(n)
#             factors = np.append(factors, 2)
#         else:
#             if n % oddtest == 0:
#                 # print(oddtest, n**2)
#                 factors = np.append(factors, oddtest)
#                 # print("appended", oddtest)
#                 n = n / oddtest
#                 n = int(n)
#                 oddtest == 3
#                 # print("reset oddtest", oddtest)
#                 if n == oddtest:
#                     # print('n = oddtest, appending and returning')
#                     factors = np.append(factors, oddtest)
#                     return factors
#             else:
#                 oddtest += 2
#
#     q = 0
#     z = 0
#     allfact = np.array([])
#     while q < len(factors):
#         allfact = np.append(allfact, (factors[q] * factors[z]))
#         z += 1
#         if z = 7:
#             z = 0
#             q += 1
#     return allfact




#print("array is", primefac(num))

n = 0
count = 0
x = 0
answer = 0
while count < 500:
    #print("n",n)
    i = 1
    if is_prime(n) == False:
        if n %2 == 0:
            #print("test",n)
            count = 0
            while i <= n*0.5:

                if (i % 2 == 0 and n % 2 == 0) or (i % 2 != 0 and n % 2 != 0):

                    if n % i == 0:
                        count += 1
                        #print("count",count)
                        if count > 500:
                            print("this number has 500 factors",n)
                            answer = n


                i += 1

    n += x
    x += 1

print("this number has 500 factors",answer)




#figured out alg for prime factorization on notes in phone
